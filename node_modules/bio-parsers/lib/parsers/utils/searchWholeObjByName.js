"use strict";

exports.__esModule = true;
exports["default"] = searchWholeObjByName;
exports.searchWholeObjByNameSimple = searchWholeObjByNameSimple;
exports.searchWholeObjByNameSimpleArray = searchWholeObjByNameSimpleArray;

var _lodash = require("lodash");

//tnr: taken from https://github.com/angus-c/waldojs (not using waldojs as it is not being maintained and pulled in nasty babel runtime transforms)

/* eslint-disable eqeqeq */
var Match = /*#__PURE__*/function () {
  function Match(props) {
    Object.assign(this, props);
    this.value = this.obj[this.prop];
  }

  var _proto = Match.prototype;

  _proto.toString = function toString() {
    var path = this.path,
        type = this.type;
    return path + " -> (" + type + ") " + this.logValue();
  };

  _proto.logValue = function logValue() {
    var val = this.value; // if value is an object then just toString it

    var isPrimitive = function isPrimitive(x) {
      return Object(x) !== x;
    };

    return isPrimitive(val) || Array.isArray(val) ? val : {}.toString.call(val);
  };

  _proto.log = function log() {
    console.info(this.toString());
  };

  return Match;
}();

var GLOBAL = typeof window == "object" ? window : global;

function searchWholeObjByName(what, where) {
  var searchBy = function searchBy(what, where, prop) {
    return what == prop;
  };

  var data;
  var alreadySeen;
  var path = where == GLOBAL ? "GLOBAL" : "SRC";
  var queue = [{
    where: where,
    path: path
  }];
  var seen = [];
  var matches = [];

  matches.log = function () {
    this.forEach(function (m) {
      return m.log();
    });
  }; // a non-recursive solution to avoid call stack limits
  // http://www.jslab.dk/articles/non.recursive.preorder.traversal.part4


  while (data = queue.pop()) {
    var _data = data,
        _where = _data.where,
        _path = _data.path;

    for (var prop in _where) {
      // IE may throw errors when accessing/coercing some properties
      try {
        if (_where.hasOwnProperty(prop)) {
          // inspect objects
          if ([_where[prop]] == "[object Object]") {
            // check if already searched (prevents circular references)
            for (var i = -1; seen[++i] && !(alreadySeen = (0, _lodash.isEqual)(seen[i].where, _where[prop]) && seen[i]);) {
              ;
            } // add to stack


            if (!alreadySeen) {
              data = {
                where: _where[prop],
                path: _path + "." + prop
              };
              queue.push(data);
              seen.push(data);
            }
          } // if match detected, push it.


          if (searchBy(what, _where, prop)) {
            var type = alreadySeen ? "<" + alreadySeen.path + ">" : typeof _where[prop];
            var match = new Match({
              path: _path + "." + prop,
              obj: _where,
              prop: prop,
              type: type
            });
            matches.push(match);
          }
        }
      } catch (e) {// don't throw errs
      }
    }
  }

  return matches;
}

function searchWholeObjByNameSimple(what, where) {
  var _searchWholeObjByName, _searchWholeObjByName2, _searchWholeObjByName3;

  return (_searchWholeObjByName = searchWholeObjByName(what, where)) === null || _searchWholeObjByName === void 0 ? void 0 : (_searchWholeObjByName2 = _searchWholeObjByName[0]) === null || _searchWholeObjByName2 === void 0 ? void 0 : (_searchWholeObjByName3 = _searchWholeObjByName2.value) === null || _searchWholeObjByName3 === void 0 ? void 0 : _searchWholeObjByName3[0];
}

function searchWholeObjByNameSimpleArray(what, where) {
  var _searchWholeObjByName4, _searchWholeObjByName5;

  return (_searchWholeObjByName4 = searchWholeObjByName(what, where)) === null || _searchWholeObjByName4 === void 0 ? void 0 : (_searchWholeObjByName5 = _searchWholeObjByName4[0]) === null || _searchWholeObjByName5 === void 0 ? void 0 : _searchWholeObjByName5.value;
}