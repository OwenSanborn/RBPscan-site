var _require = require("lodash"),
    flatMap = _require.flatMap,
    cloneDeep = _require.cloneDeep;

var bsonObjectId = require("bson-objectid");

var _require2 = require("ve-range-utils"),
    normalizePositionByRangeLength = _require2.normalizePositionByRangeLength,
    getRangeLength = _require2.getRangeLength;

var getCutsitesFromSequence = require("./getCutsitesFromSequence");

function computeDigestFragments(_ref) {
  var cutsites = _ref.cutsites,
      sequenceLength = _ref.sequenceLength,
      circular = _ref.circular,
      includeOverAndUnderHangs = _ref.includeOverAndUnderHangs,
      computePartialDigest = _ref.computePartialDigest,
      computeDigestDisabled = _ref.computeDigestDisabled,
      computePartialDigestDisabled = _ref.computePartialDigestDisabled,
      selectionLayerUpdate = _ref.selectionLayerUpdate,
      updateSelectedFragment = _ref.updateSelectedFragment;

  var fragments = [];
  var overlappingEnzymes = [];
  var pairs = [];

  var sortedCutsites = cutsites.sort(function (a, b) {
    return a.topSnipPosition - b.topSnipPosition;
  });
  if (!circular && cutsites.length) {
    sortedCutsites.push({
      id: "seqTerm_" + bsonObjectId().str,
      start: 0,
      end: 0,
      overhangBps: "",
      topSnipPosition: 0,
      bottomSnipPosition: 0,
      upstreamTopSnip: 0,
      upstreamBottomSnip: 0,
      upstreamTopBeforeBottom: false,
      topSnipBeforeBottom: false,
      recognitionSiteRange: {
        start: 0,
        end: 0
      },
      forward: true,
      name: "Sequence_Terminus",
      restrictionEnzyme: {
        name: "Sequence_Terminus"
      }
    });
  }

  sortedCutsites.forEach(function (cutsite1, index) {
    if (computePartialDigest && !computePartialDigestDisabled) {
      sortedCutsites.forEach(function (cs, index2) {
        if (index2 === index + 1 || index2 === 0) {
          return;
        }
        pairs.push([cutsite1, sortedCutsites[index2]]);
      });
    }
    if (!computeDigestDisabled) {
      pairs.push([cutsite1, sortedCutsites[index + 1] ? sortedCutsites[index + 1] : sortedCutsites[0]]);
    }
  });

  pairs.forEach(function (r) {
    var cut1 = r[0],
        cut2 = r[1];


    var start = void 0;
    var end = void 0;
    var size = void 0;
    start = normalizePositionByRangeLength(cut1.topSnipPosition, sequenceLength);
    end = normalizePositionByRangeLength(cut2.topSnipPosition - 1, sequenceLength);
    size = getRangeLength({ start: start, end: end }, sequenceLength);
    var overlapsSelf = void 0;
    if (includeOverAndUnderHangs) {
      var oldSize = size;
      start = normalizePositionByRangeLength(cut1.topSnipBeforeBottom ? cut1.topSnipPosition : cut1.bottomSnipPosition, sequenceLength);
      end = normalizePositionByRangeLength(cut2.topSnipBeforeBottom ? cut2.bottomSnipPosition - 1 : cut2.topSnipPosition - 1, sequenceLength);
      size = getRangeLength({ start: start, end: end }, sequenceLength);
      if (oldSize > size) {
        //we've got a part that wraps on itself
        overlapsSelf = true;
        size += sequenceLength;
      }
    }

    var isFormedFromLinearEnd = void 0;
    if (cut1.name === "Sequence_Terminus") {
      cut1 = cloneDeep(cut1);
      isFormedFromLinearEnd = true;
      cut1.name = "Linear_Sequence_Start";
      cut1.restrictionEnzyme.name = "Linear_Sequence_Start";
    } else if (cut2.name === "Sequence_Terminus") {
      cut2 = cloneDeep(cut2);
      isFormedFromLinearEnd = true;
      cut2.name = "Linear_Sequence_End";
      cut2.restrictionEnzyme.name = "Linear_Sequence_End";
    }

    var id = start + "-" + end + "-" + size + "-";
    var name = cut1.restrictionEnzyme.name + " -- " + cut2.restrictionEnzyme.name + " " + size + " bps";
    getRangeLength({ start: start, end: end }, sequenceLength);

    fragments.push({
      isFormedFromLinearEnd: isFormedFromLinearEnd,
      madeFromOneCutsite: cut1 === cut2,
      start: start,
      end: end,
      size: size,
      overlapsSelf: overlapsSelf,
      id: id,
      name: name,
      cut1: cut1,
      cut2: cut2,
      onFragmentSelect: selectionLayerUpdate && updateSelectedFragment ? function () {
        selectionLayerUpdate({
          start: start,
          end: end,
          name: name
        });

        updateSelectedFragment(id);
      } : undefined
    });
  });
  fragments.filter(function (fragment) {
    if (!fragment.size) {
      overlappingEnzymes.push(fragment);
      return false;
    }
    return true;
  });
  return {
    computePartialDigestDisabled: computePartialDigestDisabled,
    computeDigestDisabled: computeDigestDisabled,
    fragments: fragments,
    overlappingEnzymes: overlappingEnzymes
  };
}

function getDigestFragsForSeqAndEnzymes(_ref2) {
  var sequence = _ref2.sequence,
      circular = _ref2.circular,
      enzymes = _ref2.enzymes,
      includeOverAndUnderHangs = _ref2.includeOverAndUnderHangs;

  var cutsitesByName = getCutsitesFromSequence(sequence, circular, enzymes);
  return computeDigestFragments({
    includeOverAndUnderHangs: includeOverAndUnderHangs,
    cutsites: flatMap(cutsitesByName),
    sequenceLength: sequence.length,
    circular: circular
  });
}

module.exports.computeDigestFragments = computeDigestFragments;
module.exports.getDigestFragsForSeqAndEnzymes = getDigestFragsForSeqAndEnzymes;