"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//UNDER CONSTRUCTION

var _require = require("lodash"),
    get = _require.get;

var _require2 = require("ve-range-utils"),
    normalizePositionByRangeLength = _require2.normalizePositionByRangeLength,
    getRangeLength = _require2.getRangeLength;

module.exports = function getVirtualDigest(_ref) {
  var cutsites = _ref.cutsites,
      sequenceLength = _ref.sequenceLength,
      isCircular = _ref.isCircular,
      computePartialDigest = _ref.computePartialDigest,
      computePartialDigestDisabled = _ref.computePartialDigestDisabled,
      computeDigestDisabled = _ref.computeDigestDisabled;

  var fragments = [];
  var overlappingEnzymes = [];
  var pairs = [];

  var sortedCutsites = cutsites.sort(function (a, b) {
    return a.topSnipPosition - b.topSnipPosition;
  });

  sortedCutsites.forEach(function (cutsite1, index) {
    if (computePartialDigest && !computePartialDigestDisabled) {
      sortedCutsites.forEach(function (cs, index2) {
        // if (index2 === index + 1 || index2 === 0) { //tnw: not sure if this is necessary or not. commenting out for now
        //   return;
        // }
        pairs.push([cutsite1, sortedCutsites[index2]]);
      });
    }
    if (!computeDigestDisabled) {
      pairs.push([cutsite1, sortedCutsites[index + 1] ? sortedCutsites[index + 1] : sortedCutsites[0]]);
    }
  });

  pairs.forEach(function (_ref2) {
    var cut1 = _ref2[0],
        cut2 = _ref2[1];

    var start = normalizePositionByRangeLength(cut1.topSnipPosition, sequenceLength);
    var end = normalizePositionByRangeLength(cut2.topSnipPosition - 1, sequenceLength);

    if (!isCircular && start > end) {
      //we have a fragment that spans the origin so we need to split it in 2 pieces
      var frag1 = {
        start: start,
        end: sequenceLength - 1,
        cut1: cut1,
        cut2: {
          type: "endOfSeq",
          restrictionEnzyme: {
            name: "End Of Seq"
          }
        }
      };
      var frag2 = {
        start: 0,
        end: end,
        cut1: {
          type: "startOfSeq",
          restrictionEnzyme: {
            name: "Start Of Seq"
          }
        },
        cut2: cut2
      };

      fragments.push(addSizeIdName(frag1, sequenceLength));
      fragments.push(addSizeIdName(frag2, sequenceLength));
    } else {
      var frag = {
        cut1: cut1,
        cut2: cut2,
        start: start,
        end: end
      };
      fragments.push(addSizeIdName(frag, sequenceLength));
    }
  });
  fragments = fragments.filter(function (fragment) {
    if (!fragment.size) {
      overlappingEnzymes.push(fragment);
      return false;
    }
    return true;
  });
  return {
    computePartialDigestDisabled: computePartialDigestDisabled,
    computeDigestDisabled: computeDigestDisabled,
    fragments: fragments,
    overlappingEnzymes: overlappingEnzymes
  };
};

function addSizeIdName(frag, sequenceLength) {
  var size = getRangeLength({ start: frag.start, end: frag.end }, sequenceLength);
  var name = get(frag, "cut1.restrictionEnzyme.name", "Untitled Cutsite") + " -- " + get(frag, "cut2.restrictionEnzyme.name", "Untitled Cutsite") + " " + size + " bps";

  return _extends({}, frag, {
    size: size,
    name: name,
    id: frag.start + "-" + frag.end + "-" + size + "-"
  });
}